import fs from 'fs/promises';
import path from 'path';
import { EventEmitter } from 'events';

export class PatternEngine extends EventEmitter {
  constructor(config = {}) {
    super();
    
    this.config = {
      patternsFile: config.patternsFile || './hybrid/data/exchanges.json',
      analysisWindow: config.analysisWindow || 3600000, // 1 hour
      coordinationThreshold: config.coordinationThreshold || 3,
      updateInterval: config.updateInterval || 60000, // 1 minute
      ...config
    };
    
    // Pattern databases
    this.exchangeData = null;
    this.knownAddresses = new Map();
    this.activityPatterns = new Map();
    
    // Analysis state
    this.recentTransfers = [];
    this.coordinationCandidates = new Map();
    this.riskScores = new Map();
    
    // Metrics
    this.metrics = {
      patternsDetected: 0,
      riskAssessments: 0,
      coordinations: 0,
      exchangeInteractions: 0
    };
    
    this.initialize();
    
    console.log('[PATTERN] PatternEngine initialized', {
      analysisWindow: this.config.analysisWindow,
      coordinationThreshold: this.config.coordinationThreshold
    });
  }
  
  async initialize() {
    try {
      await this.loadPatternDatabase();
      this.startPatternAnalysis();
    } catch (error) {
      console.error('[PATTERN] Failed to initialize:', error.message);
    }
  }
  
  async loadPatternDatabase() {
    try {
      const data = await fs.readFile(this.config.patternsFile, 'utf8');
      this.exchangeData = JSON.parse(data);
      
      // Build address lookup map
      this.buildAddressMap();
      
      console.log('[PATTERN] Pattern database loaded', {
        exchanges: Object.keys(this.exchangeData.exchanges).length,
        addresses: this.knownAddresses.size,
        patterns: Object.keys(this.exchangeData.patterns).length
      });
      
    } catch (error) {
      console.error('[PATTERN] Failed to load pattern database:', error.message);
      // Create minimal fallback data
      this.exchangeData = { exchanges: {}, patterns: {}, risk_indicators: {} };
    }
  }
  
  buildAddressMap() {
    this.knownAddresses.clear();\n    \n    // Index exchange addresses\n    for (const [exchangeId, exchange] of Object.entries(this.exchangeData.exchanges)) {\n      for (const address of exchange.addresses) {\n        this.knownAddresses.set(address, {\n          type: 'exchange',\n          name: exchange.name,\n          exchangeId,\n          patterns: exchange.patterns\n        });\n      }\n    }\n    \n    // Index validator addresses\n    if (this.exchangeData.validators?.well_known) {\n      for (const address of this.exchangeData.validators.well_known) {\n        this.knownAddresses.set(address, {\n          type: 'validator',\n          name: 'Known Validator',\n          patterns: this.exchangeData.validators.patterns\n        });\n      }\n    }\n  }\n  \n  analyzeTransfer(transfer) {\n    try {\n      // Add to recent transfers for coordination analysis\n      this.addToRecentTransfers(transfer);\n      \n      // Perform pattern analysis\n      const patterns = [];\n      \n      // 1. Exchange pattern detection\n      const exchangePattern = this.detectExchangePattern(transfer);\n      if (exchangePattern) patterns.push(exchangePattern);\n      \n      // 2. Risk assessment\n      const riskAssessment = this.assessRisk(transfer);\n      if (riskAssessment) patterns.push(riskAssessment);\n      \n      // 3. Coordination detection\n      const coordinationPattern = this.detectCoordination(transfer);\n      if (coordinationPattern) patterns.push(coordinationPattern);\n      \n      // 4. Whale behavior analysis\n      const whalePattern = this.analyzeWhaleBehavior(transfer);\n      if (whalePattern) patterns.push(whalePattern);\n      \n      // 5. Temporal pattern analysis\n      const temporalPattern = this.analyzeTemporalPatterns(transfer);\n      if (temporalPattern) patterns.push(temporalPattern);\n      \n      this.metrics.patternsDetected += patterns.length;\n      \n      return {\n        transfer,\n        patterns,\n        riskScore: this.calculateRiskScore(transfer, patterns),\n        confidence: this.calculateConfidence(patterns)\n      };\n      \n    } catch (error) {\n      console.error('[PATTERN] Error analyzing transfer:', error.message);\n      return { transfer, patterns: [], riskScore: 0, confidence: 0 };\n    }\n  }\n  \n  detectExchangePattern(transfer) {\n    const fromInfo = this.knownAddresses.get(transfer.from);\n    const toInfo = this.knownAddresses.get(transfer.to);\n    \n    if (!fromInfo && !toInfo) {\n      return null; // No exchange involvement\n    }\n    \n    this.metrics.exchangeInteractions++;\n    \n    // Determine pattern type\n    let patternType, direction, exchange;\n    \n    if (fromInfo?.type === 'exchange' && toInfo?.type === 'exchange') {\n      // Exchange to exchange\n      if (fromInfo.exchangeId === toInfo.exchangeId) {\n        patternType = 'exchange_internal';\n        exchange = fromInfo.name;\n      } else {\n        patternType = 'cross_exchange';\n        exchange = `${fromInfo.name} â†’ ${toInfo.name}`;\n      }\n    } else if (fromInfo?.type === 'exchange') {\n      // Exchange withdrawal\n      patternType = 'exchange_withdrawal';\n      direction = 'outbound';\n      exchange = fromInfo.name;\n    } else if (toInfo?.type === 'exchange') {\n      // Exchange deposit\n      patternType = 'exchange_deposit';\n      direction = 'inbound';\n      exchange = toInfo.name;\n    }\n    \n    const patternConfig = this.exchangeData.patterns[patternType];\n    \n    return {\n      type: patternType,\n      confidence: 0.9,\n      metadata: {\n        exchange,\n        direction,\n        riskLevel: patternConfig?.risk_level || 'medium',\n        description: patternConfig?.description || 'Exchange interaction',\n        fromType: fromInfo?.type,\n        toType: toInfo?.type\n      }\n    };\n  }\n  \n  assessRisk(transfer) {\n    let riskScore = 0;\n    const riskFactors = [];\n    \n    // Amount-based risk\n    if (transfer.amount >= 2000000) {\n      riskScore += 0.4;\n      riskFactors.push('extremely_large_amount');\n    } else if (transfer.amount >= 1000000) {\n      riskScore += 0.3;\n      riskFactors.push('large_amount');\n    } else if (transfer.amount >= 100000) {\n      riskScore += 0.2;\n      riskFactors.push('medium_amount');\n    }\n    \n    // Timing-based risk\n    const hour = new Date(transfer.timestamp).getHours();\n    if (hour < 6 || hour > 22) { // Outside business hours\n      riskScore += 0.1;\n      riskFactors.push('unusual_timing');\n    }\n    \n    // Address-based risk\n    const fromInfo = this.knownAddresses.get(transfer.from);\n    const toInfo = this.knownAddresses.get(transfer.to);\n    \n    if (!fromInfo && !toInfo) {\n      riskScore += 0.1;\n      riskFactors.push('unknown_addresses');\n    }\n    \n    // Historical activity risk\n    const fromActivity = this.activityPatterns.get(transfer.from);\n    const toActivity = this.activityPatterns.get(transfer.to);\n    \n    if (fromActivity?.dormantDays > 180) {\n      riskScore += 0.2;\n      riskFactors.push('dormant_sender');\n    }\n    \n    if (toActivity?.dormantDays > 180) {\n      riskScore += 0.2;\n      riskFactors.push('dormant_receiver');\n    }\n    \n    this.metrics.riskAssessments++;\n    \n    if (riskScore > 0.3) {\n      return {\n        type: 'risk_assessment',\n        confidence: Math.min(riskScore, 1.0),\n        metadata: {\n          riskScore,\n          riskFactors,\n          riskLevel: riskScore > 0.7 ? 'high' : riskScore > 0.4 ? 'medium' : 'low'\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  detectCoordination(transfer) {\n    const timeWindow = this.config.analysisWindow;\n    const now = transfer.timestamp;\n    \n    // Find recent transfers involving similar addresses or amounts\n    const recentSimilar = this.recentTransfers.filter(t => {\n      if (now - t.timestamp > timeWindow) return false;\n      \n      // Check for address correlation\n      const addressMatch = t.from === transfer.from || \n                          t.to === transfer.to ||\n                          t.from === transfer.to ||\n                          t.to === transfer.from;\n      \n      // Check for amount correlation (within 10%)\n      const amountSimilar = Math.abs(t.amount - transfer.amount) / transfer.amount < 0.1;\n      \n      // Check for timing correlation (within 5 minutes)\n      const timeSimilar = Math.abs(t.timestamp - transfer.timestamp) < 300000;\n      \n      return addressMatch || (amountSimilar && timeSimilar);\n    });\n    \n    if (recentSimilar.length >= this.config.coordinationThreshold) {\n      this.metrics.coordinations++;\n      \n      return {\n        type: 'coordinated_movement',\n        confidence: Math.min(recentSimilar.length / 10, 1.0),\n        metadata: {\n          relatedTransfers: recentSimilar.length,\n          timeWindow: timeWindow / 1000 / 60, // minutes\n          coordinationType: this.classifyCoordination(recentSimilar, transfer)\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  classifyCoordination(relatedTransfers, currentTransfer) {\n    const addresses = new Set();\n    const amounts = [];\n    \n    [...relatedTransfers, currentTransfer].forEach(t => {\n      addresses.add(t.from);\n      addresses.add(t.to);\n      amounts.push(t.amount);\n    });\n    \n    const avgAmount = amounts.reduce((a, b) => a + b, 0) / amounts.length;\n    const amountVariation = Math.max(...amounts) / Math.min(...amounts);\n    \n    if (addresses.size <= 3) {\n      return 'circular_movement';\n    } else if (amountVariation < 1.2) {\n      return 'coordinated_equal_amounts';\n    } else if (avgAmount > 1000000) {\n      return 'whale_coordination';\n    } else {\n      return 'pattern_coordination';\n    }\n  }\n  \n  analyzeWhaleBehavior(transfer) {\n    if (transfer.amount < 100000) {\n      return null; // Not whale-sized\n    }\n    \n    const behaviors = [];\n    \n    // Accumulation pattern\n    const toActivity = this.getAddressActivity(transfer.to);\n    if (toActivity?.inboundVolume > transfer.amount * 3) {\n      behaviors.push('accumulation');\n    }\n    \n    // Distribution pattern\n    const fromActivity = this.getAddressActivity(transfer.from);\n    if (fromActivity?.outboundVolume > transfer.amount * 3) {\n      behaviors.push('distribution');\n    }\n    \n    // Profit taking pattern\n    if (this.isProfitTaking(transfer)) {\n      behaviors.push('profit_taking');\n    }\n    \n    if (behaviors.length > 0) {\n      return {\n        type: 'whale_behavior',\n        confidence: 0.8,\n        metadata: {\n          behaviors,\n          whaleSize: this.classifyWhaleSize(transfer.amount)\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  analyzeTemporalPatterns(transfer) {\n    const hour = new Date(transfer.timestamp).getHours();\n    const dayOfWeek = new Date(transfer.timestamp).getDay();\n    \n    const patterns = [];\n    \n    // Market hours analysis\n    if (hour >= 9 && hour <= 16 && dayOfWeek >= 1 && dayOfWeek <= 5) {\n      patterns.push('business_hours');\n    } else if (hour < 6 || hour > 22) {\n      patterns.push('off_hours');\n    }\n    \n    // Weekend activity\n    if (dayOfWeek === 0 || dayOfWeek === 6) {\n      patterns.push('weekend_activity');\n    }\n    \n    if (patterns.length > 0) {\n      return {\n        type: 'temporal_pattern',\n        confidence: 0.6,\n        metadata: {\n          patterns,\n          hour,\n          dayOfWeek,\n          isBusinessHours: patterns.includes('business_hours')\n        }\n      };\n    }\n    \n    return null;\n  }\n  \n  addToRecentTransfers(transfer) {\n    this.recentTransfers.push(transfer);\n    \n    // Clean up old transfers\n    const cutoff = transfer.timestamp - this.config.analysisWindow;\n    this.recentTransfers = this.recentTransfers.filter(t => t.timestamp > cutoff);\n  }\n  \n  getAddressActivity(address) {\n    return this.activityPatterns.get(address) || {\n      transferCount: 0,\n      inboundVolume: 0,\n      outboundVolume: 0,\n      dormantDays: 0,\n      lastActivity: null\n    };\n  }\n  \n  updateAddressActivity(transfer) {\n    // Update activity for both addresses\n    [transfer.from, transfer.to].forEach(address => {\n      if (!address) return;\n      \n      const activity = this.getAddressActivity(address);\n      activity.transferCount++;\n      activity.lastActivity = transfer.timestamp;\n      \n      if (address === transfer.from) {\n        activity.outboundVolume += transfer.amount;\n      } else {\n        activity.inboundVolume += transfer.amount;\n      }\n      \n      this.activityPatterns.set(address, activity);\n    });\n  }\n  \n  isProfitTaking(transfer) {\n    // Simple heuristic: large outbound transfer after period of accumulation\n    const fromActivity = this.getAddressActivity(transfer.from);\n    \n    return fromActivity.inboundVolume > transfer.amount * 2 &&\n           transfer.amount > 500000;\n  }\n  \n  classifyWhaleSize(amount) {\n    if (amount >= 5000000) return 'mega_whale';\n    if (amount >= 2000000) return 'large_whale';\n    if (amount >= 1000000) return 'whale';\n    if (amount >= 500000) return 'large_fish';\n    return 'fish';\n  }\n  \n  calculateRiskScore(transfer, patterns) {\n    let baseScore = 0;\n    \n    // Amount-based base score\n    if (transfer.amount >= 2000000) baseScore = 0.5;\n    else if (transfer.amount >= 1000000) baseScore = 0.4;\n    else if (transfer.amount >= 500000) baseScore = 0.3;\n    else if (transfer.amount >= 100000) baseScore = 0.2;\n    else baseScore = 0.1;\n    \n    // Pattern-based adjustments\n    for (const pattern of patterns) {\n      switch (pattern.type) {\n        case 'risk_assessment':\n          baseScore += pattern.metadata.riskScore * 0.3;\n          break;\n        case 'coordinated_movement':\n          baseScore += 0.4;\n          break;\n        case 'exchange_deposit':\n        case 'exchange_withdrawal':\n          baseScore += 0.1;\n          break;\n        case 'cross_exchange':\n          baseScore += 0.3;\n          break;\n        case 'whale_behavior':\n          baseScore += 0.2;\n          break;\n      }\n    }\n    \n    return Math.min(baseScore, 1.0);\n  }\n  \n  calculateConfidence(patterns) {\n    if (patterns.length === 0) return 0.5;\n    \n    const avgConfidence = patterns.reduce((sum, p) => sum + p.confidence, 0) / patterns.length;\n    const patternBonus = Math.min(patterns.length * 0.1, 0.3);\n    \n    return Math.min(avgConfidence + patternBonus, 1.0);\n  }\n  \n  startPatternAnalysis() {\n    // Periodic analysis and cleanup\n    setInterval(() => {\n      this.performPeriodicAnalysis();\n    }, this.config.updateInterval);\n  }\n  \n  performPeriodicAnalysis() {\n    try {\n      // Analyze global patterns\n      this.analyzeGlobalPatterns();\n      \n      // Clean up old data\n      this.cleanupOldData();\n      \n    } catch (error) {\n      console.error('[PATTERN] Error in periodic analysis:', error.message);\n    }\n  }\n  \n  analyzeGlobalPatterns() {\n    // Look for market-wide patterns\n    const recentVolume = this.recentTransfers.reduce((sum, t) => sum + t.amount, 0);\n    const transferCount = this.recentTransfers.length;\n    \n    if (recentVolume > 50000000 && transferCount > 20) { // 50M DOT in recent window\n      this.emit('globalPattern', {\n        type: 'high_volume_period',\n        volume: recentVolume,\n        transferCount,\n        timeWindow: this.config.analysisWindow\n      });\n    }\n    \n    // Detect coordinated whale movements\n    const whaleTransfers = this.recentTransfers.filter(t => t.amount > 1000000);\n    if (whaleTransfers.length >= 5) {\n      this.emit('globalPattern', {\n        type: 'whale_coordination_event',\n        whaleCount: whaleTransfers.length,\n        totalVolume: whaleTransfers.reduce((sum, t) => sum + t.amount, 0)\n      });\n    }\n  }\n  \n  cleanupOldData() {\n    const cutoff = Date.now() - this.config.analysisWindow * 2;\n    \n    // Clean up activity patterns\n    for (const [address, activity] of this.activityPatterns.entries()) {\n      if (activity.lastActivity && activity.lastActivity < cutoff) {\n        activity.dormantDays = Math.floor((Date.now() - activity.lastActivity) / 86400000);\n      }\n    }\n  }\n  \n  getMetrics() {\n    return {\n      ...this.metrics,\n      knownAddresses: this.knownAddresses.size,\n      recentTransfers: this.recentTransfers.length,\n      trackedAddresses: this.activityPatterns.size,\n      exchangeCount: Object.keys(this.exchangeData?.exchanges || {}).length\n    };\n  }\n  \n  // Public API methods\n  isExchangeAddress(address) {\n    const info = this.knownAddresses.get(address);\n    return info?.type === 'exchange';\n  }\n  \n  isValidatorAddress(address) {\n    const info = this.knownAddresses.get(address);\n    return info?.type === 'validator';\n  }\n  \n  getAddressInfo(address) {\n    return this.knownAddresses.get(address) || null;\n  }\n  \n  async updatePatternDatabase(newData) {\n    try {\n      this.exchangeData = { ...this.exchangeData, ...newData };\n      this.buildAddressMap();\n      \n      await fs.writeFile(\n        this.config.patternsFile,\n        JSON.stringify(this.exchangeData, null, 2)\n      );\n      \n      console.log('[PATTERN] Pattern database updated');\n    } catch (error) {\n      console.error('[PATTERN] Failed to update pattern database:', error.message);\n    }\n  }\n}"